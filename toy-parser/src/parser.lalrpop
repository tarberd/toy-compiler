use crate::ast::*;

grammar;

pub Module: Ast = {
    StatementList => Ast::Module { contents: <> },
};

StatementList: Vec<Ast> = {
    Statement* => <>,
};

Statement: Ast = {
    FunctionDeclaration,
    FunctionDefinition,
    VariableDefinition,
};


FunctionDeclaration: Ast = {
    "fn" <id: Identifier> "(" <parameters: ParameterList?> ")" ";" => {
        let parameters = match parameters {
            Some(parameters) => parameters,
            None => vec![],
        };

        Ast::FunctionDeclaration { id, parameters }
    },
};

FunctionDefinition: Ast = {
    "fn" <id: Identifier> "(" <parameters: ParameterList?>  ")" "=>" <body: Expression> ";" => {
        let parameters = match parameters {
            Some(parameters) => parameters,
            None => vec![],
        };

        Ast::FunctionDefinition { id, parameters, body: Box::new(body) }
    },
};

ParameterList: Vec<String> = {
    <mut id_list: (Identifier ",")*>  <id: Identifier> ","? => {
        let mut id_list: Vec<String> = id_list.drain(..).map(|x| x.0).collect();
        id_list.push(id);
        id_list
    },
};

VariableDefinition: Ast = {
    "let" <id: Identifier> "=" <expression: Expression> ";" => {
        Ast::VariableDefinition { id, expression: Box::new(expression) }
    },
};

Identifier: String = {
    r"[_[:alpha:]][_[:alnum:]]*" => <>.to_string(),
};

IntegerLiteral: Ast = {
    r"[[:digit:]]+" => Ast::IntegerLiteral { value: <>.parse().unwrap() },
};

Expression: Ast = {
    TermExpression,
};

TermExpression: Ast = {
    <left: TermExpression> <op: TermOperator> <right: FactorExpression> => Ast::BinaryExpression {
        operator: op,
        left: Box::new(left),
        right: Box::new(right),
    },
    FactorExpression,
};

TermOperator: Operator = {
    "+" => Operator::Plus,
    "-" => Operator::Minus,
};

FactorExpression: Ast = {
    <left: FactorExpression> <op: FactorOperator> <right: UnaryFactorExpression> => Ast::BinaryExpression {
        operator: op,
        left: Box::new(left),
        right: Box::new(right),
    },
    UnaryFactorExpression,
};

FactorOperator: Operator = {
    "*" => Operator::Mul,
    "/" => Operator::Div,
};

UnaryFactorExpression: Ast = {
    <op: UnaryFactorOperator> <expression: BlockExpression> => Ast::UnaryExpression {
        operator: op,
        expression: Box::new(expression),
    },
    BlockExpression,
};

UnaryFactorOperator: Operator = {
    "-" => Operator::Neg,
    "&" => Operator::Deref,
};

BlockExpression: Ast = {
    "{" <statement_list: StatementList> <return_expression: Expression> "}" => {
        Ast::BlockExpression {
            statements: statement_list,
            return_expression: Box::new(return_expression),
        }
    },
    FunctionCallExpression,
};

FunctionCallExpression: Ast = {
    <id: Identifier> "(" <args: ArgumentList?> ")" => {
        let arguments = match args {
            Some(args) => args,
            None => vec![],
        };

        Ast::CallExpression {
            id,
            arguments,
        }
    },
    NestedExpression,
};

ArgumentList: Vec<Ast> = {
    <mut expr_list: (Expression",")*>  <expr: Expression> ","? => {
        let mut expr_list: Vec<Ast> = expr_list.drain(..).map(|x| x.0).collect();
        expr_list.push(expr);
        expr_list
    },
};

NestedExpression: Ast = {
    "(" <expr: Expression> ")" => expr,
    LeafExpression,
};

LeafExpression: Ast = {
    IntegerLiteral,
    Identifier => Ast::Identifier { id: <> },
};
