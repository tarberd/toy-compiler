use crate::ast::*;
use toy_lexer::{Token, LiteralKind, Span};

grammar;

extern {
    type Location = usize;
    type Error = ();

    enum Token {
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "," => Token::Comma,
        "(" => Token::OpenParentheses,
        ")" => Token::CloseParentheses,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "=" => Token::Equals,
        "==" => Token::DoubleEquals,
        "=>" => Token::FatArrow,
        "->" => Token::Arrow,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "fn" => Token::Function,
        "let" => Token::Let,
        Identifier => Token::Identifier,
        Literal => Token::Literal(<LiteralKind>),
    }
}

pub RootModule: RootModule = {
    <functions: Function*> => RootModule::new(functions),
}

Function: Function = {
  "fn" <id: Id> "(" <params: ParameterList> ")"
  "->" <return_type_id: Id> <body: Block> => {
      Function::new(id, params, return_type_id, body)
  }
}

ParameterList: Vec<Parameter> = {
    <parameters: (Id ":" Id ",")*> <trailing: (Id ":" Id)?> => {
        parameters.into_iter()
            .map(|(id, _, type_id, _)| Parameter::new(id, type_id))
            .chain(
                trailing.into_iter()
                    .map(|(id, _, type_id)| Parameter::new(id, type_id))
            )
            .collect()
    }
}

Block: Block = {
    "{" <expr: Expression> "}" => Block::new(expr),
}

Id: Id = {
   <l:@L> <id: Identifier> <r:@R> => Id::new(Span::new(l, r - l)),
}

Expression: Expression = {
    Terms,
}

Terms: Expression = {
    <l:@L> <lhs: Terms> <op: TermOp> <rhs: LiteralExpr> <r:@R> => {
        Expression::new(
            ExpressionKind::Binary(
                Box::new(lhs),
                op,
                Box::new(rhs),
            ),
            Span::new(l, r - l),
        )
    },
    LiteralExpr,
}

TermOp: BinaryOperator = {
    "+" => BinaryOperator::Sum,
}

LiteralExpr: Expression = {
    <l:@L> <lit: Literal> <r:@R> => {
        match lit {
            LiteralKind::Integer { suffix_offset } => {
                Expression::new(
                    ExpressionKind::Literal(
                        match suffix_offset {
                            Some(off) => Literal::new(
                                Span::new(l, off),
                                Some(Span::new(l + off, r - (l + off))),
                            ),
                            None => Literal::new(Span::new(l, r-l), None),
                        }
                    ),
                    Span::new(l, r - l),
                )
            }
        }
    }
}
