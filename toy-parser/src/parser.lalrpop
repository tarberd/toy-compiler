use crate::ast::*;

grammar;

pub Module: Ast = {
    StatementList => Ast::Module { contents: <> },
};

StatementList: Vec<Ast> = {
    Statement* => <>,
};

Statement: Ast = {
    <s: FunctionDeclaration> ";" => s,
    <s: FunctionDefinition> ";" => s,
    <s: VariableDefinition> ";" => s,
};

FunctionDeclaration: Ast = {
    "fn" <id: Identifier> "(" <parameters: ParameterList?> ")" => {
        let parameters = match parameters {
            Some(parameters) => parameters,
            None => vec![],
        };

        Ast::FunctionDeclaration { id, parameters }
    },
};

FunctionDefinition: Ast = {
    "fn" <id: Identifier> "(" <parameters: ParameterList?>  ")" "=>" <body: Expression> => {
        let parameters = match parameters {
            Some(parameters) => parameters,
            None => vec![],
        };

        Ast::FunctionDefinition { id, parameters, body: Box::new(body) }
    },
};

ParameterList: Vec<(String, Type)> = {
    <mut id_list: (Parameter ",")*>  <id: Parameter> ","? => {
        let mut id_list: Vec<(String, Type)> = id_list.drain(..).map(|x| x.0).collect();
        id_list.push(id);
        id_list
    },
};

Parameter: (String, Type) = {
    <id: Identifier> ":" <type_: Type> => (id, type_),
};

VariableDefinition: Ast = {
    "let" <id: Identifier> ":" <type_id: Type> "=" <expression: Expression> => {
        Ast::VariableDefinition { type_id, id, expression: Box::new(expression) }
    },
};

Type: Type = {
    "i32" => Type::I32,
    PointerType,
    ArrayType,
};

PointerType: Type = {
    "*" <type_id: Type> => Type::Pointer { type_id: Box::new(type_id) },
};

ArrayType: Type = {
    "[" <type_id: Type> ";" <size: Expression> "]" => {
        Type::Array {
            type_id: Box::new(type_id),
            size: Box::new(size),
        }
    },
};

Identifier: String = {
    r"[_[:alpha:]][_[:alnum:]]*" => <>.to_string(),
};

IntegerLiteral: Ast = {
    r"[[:digit:]]+" => Ast::IntegerLiteral { value: <>.parse().unwrap() },
};

ArrayLiteral: Ast = {
    "[" <values: ExpressionList> "]" => Ast::ArrayLiteral { values },
}

Expression: Ast = {
    TermExpression,
};

TermExpression: Ast = {
    <left: TermExpression> <op: TermOperator> <right: FactorExpression> => Ast::BinaryExpression {
        operator: op,
        left: Box::new(left),
        right: Box::new(right),
    },
    FactorExpression,
};

TermOperator: Operator = {
    "+" => Operator::Plus,
    "-" => Operator::Minus,
};

FactorExpression: Ast = {
    <left: FactorExpression> <op: FactorOperator> <right: UnaryFactorExpression> => Ast::BinaryExpression {
        operator: op,
        left: Box::new(left),
        right: Box::new(right),
    },
    UnaryFactorExpression,
};

FactorOperator: Operator = {
    "*" => Operator::Mul,
    "/" => Operator::Div,
};

UnaryFactorExpression: Ast = {
    <op: UnaryFactorOperator> <expression: BlockExpression> => Ast::UnaryExpression {
        operator: op,
        expression: Box::new(expression),
    },
    BlockExpression,
};

UnaryFactorOperator: Operator = {
    "-" => Operator::Neg,
    "&" => Operator::Deref,
};

BlockExpression: Ast = {
    "{" <statement_list: StatementList> <return_expression: Expression> "}" => {
        Ast::BlockExpression {
            statements: statement_list,
            return_expression: Box::new(return_expression),
        }
    },
    FunctionCallExpression,
};

FunctionCallExpression: Ast = {
    <id: Identifier> "(" <arguments: ExpressionList> ")" => {
        Ast::CallExpression {
            id,
            arguments,
        }
    },
    NestedExpression,
};

ExpressionList: Vec<Ast> = {
    <mut expr_list: (Expression ",")*>  <expr: Expression> ","? => {
        let mut expr_list: Vec<Ast> = expr_list.drain(..).map(|x| x.0).collect();
        expr_list.push(expr);
        expr_list
    },
    () => vec![],
};

NestedExpression: Ast = {
    "(" <expr: Expression> ")" => expr,
    LeafExpression,
};

LeafExpression: Ast = {
    ArrayLiteral,
    IntegerLiteral,
    Identifier => Ast::Identifier { id: <> },
};
