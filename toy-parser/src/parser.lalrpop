use crate::ast::*;

grammar;

pub Module: ModuleStatement = {
    StatementList => {
        ModuleStatement {
            id: Identifier { value: "root".to_string() },
            statements: <>,
        }
    },
};

StatementList: Vec<Statement> = {
    Statement* => <>,
};

Statement: Statement = {
    <s: ExternFunctionDeclaration> ";" => Statement::ExternFunctionDeclaration(Box::new(s)),
    <s: FunctionDefinition> ";" => Statement::FunctionDefinition(Box::new(s)),
    <s: VariableDefinition> ";" => Statement::VariableDefinition(Box::new(s)),
};

ExternFunctionDeclaration: ExternFunctionDeclarationStatement = {
    "extern" "fn" <id: Identifier> "(" <parameters: ParameterList?> ")" <return_type: (":" Type)?> => {
        let parameters = match parameters {
            Some(parameters) => parameters,
            None => vec![],
        };

        let return_type = match return_type {
            Some((_, type_)) => type_,
            None => Type::Void,
        };

        ExternFunctionDeclarationStatement { id, parameters, return_type }
    },
};

FunctionDefinition: FunctionDefinitionStatement = {
    "fn" <id: Identifier> "(" <parameters: ParameterList?>  ")" <return_type: (":" Type)?> "=>" <body: Expression> => {
        let parameters = match parameters {
            Some(parameters) => parameters,
            None => vec![],
        };

        let return_type = match return_type {
            Some((_, type_)) => type_,
            None => Type::Void,
        };

        FunctionDefinitionStatement { id, parameters, return_type, body }
    },
};

ParameterList: Vec<(Identifier, Type)> = {
    <mut id_list: (Parameter ",")*>  <id: Parameter> ","? => {
        let mut id_list: Vec<(Identifier, Type)> = id_list.drain(..).map(|x| x.0).collect();
        id_list.push(id);
        id_list
    },
};

Parameter: (Identifier, Type) = {
    <id: Identifier> ":" <type_: Type> => (id, type_),
};

VariableDefinition: VariableDefinitionStatement = {
    "let" <id: Identifier> ":" <type_: Type> "=" <initialize_expression: Expression> => {
        VariableDefinitionStatement { id, type_, initialize_expression }
    },
};

Type: Type = {
    "i32" => Type::I32,
    PointerType,
    ArrayType,
};

PointerType: Type = {
    "*" <type_id: Type> => Type::Pointer { type_id: Box::new(type_id) },
};

ArrayType: Type = {
    "[" <type_id: Type> ";" <size: Expression> "]" => {
        Type::Array {
            type_id: Box::new(type_id),
            size,
        }
    },
};

Identifier: Identifier = {
    r"[_[:alpha:]][_[:alnum:]]*" => Identifier { value: <>.to_string() },
};


Expression: Expression = {
    TermExpression,
};

TermExpression: Expression = {
    <left: TermExpression> <op: TermOperator> <right: FactorExpression> => {
        let bi_op = BinaryExpression {
            operator: op,
            left: left,
            right: right,
        };

        Expression::Binary(Box::new(bi_op))
    },
    FactorExpression,
};

TermOperator: BinaryOperator = {
    "+" => BinaryOperator::Plus,
    "-" => BinaryOperator::Minus,
};

FactorExpression: Expression = {
    <left: FactorExpression> <op: FactorOperator> <right: UnaryFactorExpression> => {
        let bi_op = BinaryExpression {
            operator: op,
            left: left,
            right: right,
        };

        Expression::Binary(Box::new(bi_op))
    },
    UnaryFactorExpression,
};

FactorOperator: BinaryOperator = {
    "*" => BinaryOperator::Multiplication,
    "/" => BinaryOperator::Division,
};

UnaryFactorExpression: Expression = {
    <op: UnaryFactorOperator> <expression: BlockExpression> => {
        let u_op = UnaryExpression {
            operator: op,
            expression: expression,
        };

        Expression::Unary(Box::new(u_op))
    },
    BlockExpression,
};

UnaryFactorOperator: UnaryOperator = {
    "-" => UnaryOperator::Minus,
    "&" => UnaryOperator::Deref,
};

BlockExpression: Expression = {
    "{" <statements: StatementList> <return_expression: Expression?> "}" => {
        let block = BlockExpression {
            statements,
            return_expression,
        };

        Expression::Block(Box::new(block))
    },
    FunctionCallExpression,
};

FunctionCallExpression: Expression = {
    <callee: NestedExpression> "(" <arguments: ExpressionList> ")" => {
        let call = CallExpression {
            callee,
            arguments,
        };

        Expression::Call(Box::new(call))
    },
    NestedExpression,
};

ExpressionList: Vec<Expression> = {
    <mut expr_list: (Expression ",")*>  <expr: Expression> ","? => {
        let mut expr_list: Vec<Expression> = expr_list.drain(..).map(|x| x.0).collect();
        expr_list.push(expr);
        expr_list
    },
    () => vec![],
};

NestedExpression: Expression = {
    "(" <expr: Expression> ")" => expr,
    LeafExpression,
};

LeafExpression: Expression = {
    ArrayLiteral => Expression::Array(<>),
    IntegerLiteral => Expression::Integer(<>),
    Identifier => Expression::Identifier(<>),
};

IntegerLiteral: IntegerLiteral  = {
    r"[[:digit:]]+" => IntegerLiteral { value: <>.parse().unwrap() },
};

ArrayLiteral: ArrayLiteral = {
    "[" <initialize_expressions: ExpressionList> "]" => ArrayLiteral { initialize_expressions },
}
