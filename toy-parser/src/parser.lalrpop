use crate::ast::*;

grammar;

pub Module: ModuleStatement = {
    StatementList => {
        ModuleStatement {
            id: Identifier { value: "root".to_string() },
            statements: <>,
        }
    },
};

StatementList: Vec<Statement> = {
    Statement* => <>,
};

Statement: Statement = {
    <s: ExternFunctionDeclaration> ";" => Statement::ExternFunctionDeclaration(Box::new(s)),
    <s: FunctionDefinition> ";" => Statement::FunctionDefinition(Box::new(s)),
    <s: VariableDefinition> ";" => Statement::VariableDefinition(Box::new(s)),
};

ExternFunctionDeclaration: ExternFunctionDeclarationStatement = {
    "extern" "fn" <id: Identifier> "(" <parameters: ParameterList?> ")" <return_type: (":" Type)?> => {
        let parameters = match parameters {
            Some(parameters) => parameters,
            None => vec![],
        };

        let return_type = match return_type {
            Some((_, type_)) => type_,
            None => Type::Void,
        };

        ExternFunctionDeclarationStatement { id, parameters, return_type }
    },
};

FunctionDefinition: FunctionDefinitionStatement = {
    "fn" <id: Identifier> "(" <parameters: ParameterList?>  ")" <return_type: (":" Type)?> "=>" <body: Expression> => {
        let parameters = match parameters {
            Some(parameters) => parameters,
            None => vec![],
        };

        let return_type = match return_type {
            Some((_, type_)) => type_,
            None => Type::Void,
        };

        FunctionDefinitionStatement { id, parameters, return_type, body }
    },
};

ParameterList: Vec<(Identifier, Type)> = {
    <mut id_list: (Parameter ",")*>  <id: Parameter> ","? => {
        let mut id_list: Vec<(Identifier, Type)> = id_list.drain(..).map(|x| x.0).collect();
        id_list.push(id);
        id_list
    },
};

Parameter: (Identifier, Type) = {
    <id: Identifier> ":" <type_: Type> => (id, type_),
};

VariableDefinition: VariableDefinitionStatement = {
    "let" <id: Identifier> ":" <type_: Type> "=" <initialize_expression: Expression> => {
        VariableDefinitionStatement { id, type_, initialize_expression }
    },
};

Type: Type = {
    BooleanType,
    IntegerType,
    PointerType,
    ArrayType,
};

IntegerType: Type = {
    "i8" => Type::I8,
    "i16" => Type::I16,
    "i32" => Type::I32,
    "i64" => Type::I64,
    "isize" => Type::ISize,
    "u8" => Type::U8,
    "u16" => Type::U16,
    "u32" => Type::U32,
    "u64" => Type::U64,
    "usize" => Type::USize,
};

BooleanType: Type = {
    "bool" => Type::Boolean,
};

PointerType: Type = {
    "*" <type_id: Type> => Type::Pointer { type_id: Box::new(type_id) },
};

ArrayType: Type = {
    "[" <type_id: Type> ";" <size: Expression> "]" => {
        Type::Array {
            type_id: Box::new(type_id),
            size,
        }
    },
};

Identifier: Identifier = {
    r"[_[:alpha:]][_[:alnum:]]*" => Identifier { value: <>.to_string() },
};


Expression: Expression = {
    BinaryBooleanExpression,
};

BinaryBooleanExpression: Expression = {
    <left: BinaryBooleanExpression> <op: BinaryBooleanOperator> <right: UnaryBooleanExpression> => {
        let bi_op = BinaryExpression {
            operator: op,
            left: left,
            right: right,
        };

        Expression::Binary(Box::new(bi_op))
    },
    UnaryBooleanExpression,
};

BinaryBooleanOperator: BinaryOperator = {
    "&&" => BinaryOperator::And,
    "and" => BinaryOperator::And,
    "||" => BinaryOperator::Or,
    "or" => BinaryOperator::Or,

    ">" => BinaryOperator::GreaterThan,
    ">=" => BinaryOperator::GreaterEqualThan,
    "==" => BinaryOperator::Equal,
    "<=" => BinaryOperator::LessEqualThan,
    "<" => BinaryOperator::LessThan,
};

UnaryBooleanExpression: Expression = {
    <op: UnaryBooleanOperator> <expression: TermExpression> => {
        let u_op = UnaryExpression {
            operator: op,
            expression: expression,
        };

        Expression::Unary(Box::new(u_op))
    },
    TermExpression,
};

UnaryBooleanOperator: UnaryOperator = {
    "!" => UnaryOperator::Not,
    "not" => UnaryOperator::Not,
};

TermExpression: Expression = {
    <left: TermExpression> <op: TermOperator> <right: FactorExpression> => {
        let bi_op = BinaryExpression {
            operator: op,
            left: left,
            right: right,
        };

        Expression::Binary(Box::new(bi_op))
    },
    FactorExpression,
};

TermOperator: BinaryOperator = {
    "+" => BinaryOperator::Plus,
    "-" => BinaryOperator::Minus,
};

FactorExpression: Expression = {
    <left: FactorExpression> <op: FactorOperator> <right: UnaryFactorExpression> => {
        let bi_op = BinaryExpression {
            operator: op,
            left: left,
            right: right,
        };

        Expression::Binary(Box::new(bi_op))
    },
    UnaryFactorExpression,
};

FactorOperator: BinaryOperator = {
    "*" => BinaryOperator::Multiplication,
    "/" => BinaryOperator::Division,
};

UnaryFactorExpression: Expression = {
    <op: UnaryFactorOperator> <expression: BlockExpression> => {
        let u_op = UnaryExpression {
            operator: op,
            expression: expression,
        };

        Expression::Unary(Box::new(u_op))
    },
    BlockExpression,
};

UnaryFactorOperator: UnaryOperator = {
    "-" => UnaryOperator::Minus,
    "&" => UnaryOperator::Deref,
};

BlockExpression: Expression = {
    "{" <statements: StatementList> <return_expression: Expression?> "}" => {
        let block = BlockExpression {
            statements,
            return_expression,
        };

        Expression::Block(Box::new(block))
    },
    FunctionCallExpression,
};

FunctionCallExpression: Expression = {
    <callee: NestedExpression> "(" <arguments: ExpressionList> ")" => {
        let call = CallExpression {
            callee,
            arguments,
        };

        Expression::Call(Box::new(call))
    },
    NestedExpression,
};

ExpressionList: Vec<Expression> = {
    <mut expr_list: (Expression ",")*>  <expr: Expression> ","? => {
        let mut expr_list: Vec<Expression> = expr_list.drain(..).map(|x| x.0).collect();
        expr_list.push(expr);
        expr_list
    },
    () => vec![],
};

NestedExpression: Expression = {
    "(" <expr: Expression> ")" => expr,
    LeafExpression,
};

LeafExpression: Expression = {
    ArrayLiteral => Expression::Array(<>),
    IntegerLiteral => Expression::Integer(Box::new(<>)),
    BooleanLiteral => Expression::Boolean(<>),
    Identifier => Expression::Identifier(<>),
};

IntegerLiteral: IntegerLiteral = {
    <value: r"([[:digit:]]+_*)+"> <suffix: IntegerType?> => {
        let value = value.to_string().replace("_", "");
        match suffix {
            Some(suffix) => {
                IntegerLiteral {
                    value: value.parse().unwrap(),
                    type_: suffix,
                }
            },
            None => {
                IntegerLiteral {
                    value: value.parse().unwrap(),
                    type_: Type::IntegerLiteral,
                }
            },
        }
    },
};

BooleanLiteral: BooleanLiteral = {
    "true" => BooleanLiteral { value: true },
    "false" => BooleanLiteral { value: false },
}

ArrayLiteral: ArrayLiteral = {
    "[" <initialize_expressions: ExpressionList> "]" => ArrayLiteral { initialize_expressions },
};
